#ifndef PROCESSOR_H
#define PROCESSOR_H

#include <iostream>
#include <exception>

#include <vector>
#include <unordered_set>
#include <initializer_list>
#include "../../dictionary/dictionary.hpp"

#include "types.h"
#include "operands.h"
#include "memory.h"

#include "command.h"

/*!
	@file
	@brief основной заголовок библиотеки эмулятора процессора. Содежит объявление, собственно, класса процессора
	@author Jawa Prog
	@version 1.0
	@date Декабрь 2020 года
*/


namespace jpl
{
	// реализация классов 
	
	/// Устройство Управления (УУ).
	class controller
	{
		private:
		uint64_t time = 0; ///< системное время (количество тиков, выполненых с момента инициализации)
		public:
		/*!
			@brief функция выполняет один полный цикл работы процессора. То есть посылает сигнал такта на все АЛУ, пытается выполнить очередную команду из памяти программы.
			@param ссылка на процессор
			@return возвращает true, если еще есть команды в памяти програм.
		*/
		bool on_tick(processor&);
		
	};
	/// Арифметико-Логическое Устройство. Выполняет переданные команды, если используемые операторы принадлежат списку поддерживаемых данным АЛУ
	class ALU
	{
		private:
		uint64_t dur, fre;
		std::unordered_set<const operator_*> avcom;
		const command *last ; 
		public:
		/*!
			@brief конструктор инициализирует АЛУ с указанным временем выполнения операции и пустым списком поддерживаемых операторов
			@param dur_ количество тиков, требуемое на выполнение одного оператора			
		*/
		ALU(uint64_t dur_) : dur(dur_), fre(0), last(nullptr) {}
		/*!
			@brief конструктор инициализирует АЛУ с указанными временем выполнения операции и списком поддерживаемых операторов
			@param dur_ количество тиков, требуемое на выполнение одного оператора			
			@param cmds вектор константных ссылок на объекты операторы.
		*/
		ALU(uint64_t dur_, std::vector<const operator_*> cmds) : dur(dur_), fre(0), last(nullptr)
		{
			avcom.insert(cmds.begin(), cmds.end());
		}
		/*!
			@brief оператор проверяет, возможно ли сейчас приступить к выполнению данной команды. Если так, то указатель на команду сохраняется в АЛУ для последующего исполнения. При этом, все операнды команды блокируются на время исполнения.
			@details Команда принимается к исполнению, если выполнение предыдущей команды уже завершено, содержащийся в новой комаде оператор поддерживается АЛУ и если все операнды команды были успешны заблокированы данным АЛУ.
			@param proc ссылка на процессор
			@param cmd_n ссылка на описатель команды
			@param time системное время
			@return возвращает true, если команда принята к исполнению. Иначе false. 
		*/
		bool operator()(processor&, const command&, int);
		/*!
			@brief передает такт в АЛУ. Если <время принятия команды к исполнению> + <время исполнения одной команды> меньше или равно переданному системному времени, то прошлая команда выполняется, ее операнды разблокируются и АЛУ становится доступен для принятия новых команд.
			@param proc ссылка на процессор
			@param системное время
			@return true, если сейчас нет исполняемой команды (или она была завершена во время текущего вызова). Если выполнение команды не завершено, то возвращается false
		*/
		bool operator()(processor&, int);
		
		/*!
			@brief метод пытается заблокировать операнд. Владельцем блокировки выступает экземпляр АЛУ. Константные операнды пропускаются
			@param proc ссылка на процессор
			@param op ссылка на операнд.
			@return true, если блокировка прошла успешно, или предыдущая блокировка наложена этим же АЛУ. false, если операнд уже заблокирован другим АЛУ. Для константных операндов (в т.ч. и для меток) метод всегда возвращает true
		*/
		bool lock(processor &proc, const operand& op);
		/*!
			@brief метод пытается снять блокировку с операнда. Константные операнды пропускаются
			@param proc ссылка на процессор
			@param op ссылка на операнд.
			@throws std::logic_error() если данное АЛУ не является владельцем блокировки, которую пытается снять
		*/
		void unlock(processor &proc, const operand& op);
		
		/*!
			@brief метод добавляет новый оператор в набор поддерживаемых операторов 
			@param op константный указатель на оператор
		*/
		void add_operator(const operator_* op){avcom.insert(op);}
		/*!
			@brief метод удаляет оператор из набора поддерживаемых операторов 
			@param op константный указатель на оператор
		*/
		void remove_operator(const operator_* op){avcom.erase(op);}
		
		/*!
			@brief метод возвращает флаг состояния АЛУ
			@return true, если АЛУ выполняет какую-либо команду.
		*/
		bool is_running() const {return last;}
		/*!
			@brief метод проверяет, поддерживается ли переданный оператор
			@param op константный указатель на оператор
			@return true, если указатель на переданный оператор содержится в наборе поддерживаемых операторов.
		*/
		bool is_available(const operator_ &op) const {return avcom.find(&op) != avcom.cend();}
	};
	/// класс памяти программ. Хранит основную информацию о программе (последовательность инструкций, словарь "метка"-"число", количство статически выделяемой памяти)
	class progmem
	{
		private:
		std::vector<command> prog; ///< последовательность команд
		dictionary<std::string, int> vars; ///< таблица соответсвия имен переменных и адресов в ОП и имен меток с номерами команд
		int  weight = 0; ///< количество байт, которые выделяются статически (с помощью ключевого слова VAR)
		public:
		// определять свои конструкторы не надо, так как поля типа vector, dictionary и int сами заботятся о своем копировании и уничтожении
		
		/*!
			метод вставляет команду на переданную позицию. Если число меньше нуля, то вставка идет в конец
			@param cmd команда для вставки
			@param p = -1 позиция для вставки. Любое отрицательное значение приводит к вставке в конец программы.
		*/
		void insert(const command& cmd, int p = -1);
		/*!
			метод удаляет команду по переданной позиции. При необходимости значение веса инкрементируется.
			@param nm номер команды в программе
		*/
		void erase(int nm);
		/*!
			оператор возвращает команду по ее номеру. При необходимости значение веса инкрементируется.
			@param i позиция команды в памяти програм
			@return константная ссылка на команду
		*/		
		const command& operator[](int i) const {return prog[i];}
		/// очищает память программ.
		void clear() {prog.clear(), weight = 0;}
		/// возвращает количество команд в памяти программ
		int size() const {return prog.size();}
		
		/// возвращает вес программы (необходимое под статические переменные место)
		int get_weight() const {return weight;}
		
		// работа с именами переменных
		/*!
			возвращает фактическое значение метки или имени переменного
			@param var строка. Метка или имя переменного
			@return фактическое значение (адрес команды или данных)
		*/		
		byte unname(const std::string &var) const {return vars[var];}
		/*!
			устанавливает новое фактическое значение метки или имени переменного
			@param var строка. Метка или имя переменного
			@param adr новое фактическое значение
		*/	
		void set_name(const std::string &var, const int &adr) {return vars.set(var, adr);}
		/*!
			удаляет указанную метку или имя переменного из словаря.
			@param var строка. Метка или имя переменного
		*/	
		void remove_name(const std::string &var) {return vars.unset(var);}
		
		/// вывод в поток исходного текста программы
		friend std::ostream& operator<<(std::ostream&, const progmem&);
	};
	/// класс описателя процесса. Процесс автоматически создается в методе процессора run.
	class process {
		private:
		std::vector<byte> stack; ///< вектор для хранения стека процесса
		int st_cou; ///< вершина стека
		
		const progmem *prog; ///< указатель на область памяти процесса (гарантируется, что выполнение программы не меняет ее)
		int counter = 0; ///< счётчик текущей команды
		int base = 0; ///<смещение области данных процесса в ОП.
		public:		
		/// конструктор иницавлизирует процесс без программы
		process() : prog(nullptr), st_cou(0) {} 		
		/// конструктор иницавлизирует процесс указанной программой. счетчик устанавливается по метке start из памяти программы, если такой метки нет, то в 0
		process(const progmem &prog_) : prog(&prog_), st_cou(0) {
			try{
				counter = prog->unname("start");
			}
			catch (const std::exception &e)
			{
				counter = 0;
			}
		} 		
		/// метод возвращает константную ссылку на память программ
		const progmem& get_progmem() const {return *prog;}		
		/// @return true если еще есть команды для исполнения (значение в счетчике меньше чем количество команд). Иначе - false
		bool has_next(){return counter < prog->size();}
		/// устанавливает смещение области памяти данного процесса в ОП (от этого зависит обращение к статическим переменным)
		void set_base(int b) {base = b;}
		/// возвращает смещение области данных данного процесса в ОП
		int get_base() const {return base;}
		/// возвращает текущее значение счетчика команд
		int count() const {return counter;}
		/// инкрементирует счетчик
		void inc() {++counter;}
		/// устанавливает счетчик
		void jump(int a) {counter = a;}	
		
		/// помещает байт информации на стек
		void push(byte b){
			if(st_cou == (int)stack.size()){
				stack.push_back(b);
			}
			else stack[st_cou] = b;
			++st_cou;
		}
		/// снимает байт инфомации со стека
		byte pop(){return stack[--st_cou];}
		/// произвольный доступ к данным со стека (i - отступ от вершины стека)
		byte stack_i(int i){return stack[st_cou-i-1];}		
		
		/// передает константный указатель на текущую команду для исполнения
		const command& current() const {return (*prog)[counter];}
		
	};
	/// класс процессора. Процессор определяется набором АЛУ, блоком регистров и указателем на память.
	class processor
	{
		private:
		controller control;
		std::vector<ALU> alus;
				
		registers_block regs; // блок регистров это свойство самого процессора
		RAM *ram; // но оперативная память явлется самостоятельным устройством, к которому могут обращаться несколько процессоров.
		process prog; 
		public:
		/*!
			@brief конструктор процессора. Инициализация одним АЛУ, количеством регистров и указателем на ОП.
			@param alu экземпляр класса АЛУ
			@param regs_ количество регистров в блоке регистров процессора
			@param ram_ указатель на экземпляр оперативной памяти
		*/
		processor(const ALU& alu, int regs_, RAM *ram_ = nullptr) : ram(ram_), regs(regs_) {alus.push_back(alu);}
		/*!
			@brief конструктор процессора. Инициализация набором АЛУ, количеством регистров и указателем на ОП.
			@param alus_ вектор экземпляров АЛУ
			@param regs_ количество регистров в блоке регистров процессора
			@param ram_ указатель на экземпляр оперативной памяти
		*/
		processor(const std::vector<ALU> &alus_, int regs_, RAM *ram_ = nullptr) : ram(ram_), alus(alus_), regs(regs_) {}
		/*!
			@brief конструктор процессора. Инициализация набором АЛУ, количеством регистров и указателем на ОП.
			@param alus_ вектор экземпляров АЛУ
			@param regs_ количество регистров в блоке регистров процессора
			@param ram_ указатель на экземпляр оперативной памяти
		*/
		processor(std::vector<ALU> &&alus_, int regs_, RAM *ram_ = nullptr) : ram(ram_), alus(alus_), regs(regs_) {}
		
		
		/*!
			@brief начинает выполнение команды. 
			@details При необходимости запустить выполнение метода в отдельном потоке можно использовать подобную команду:
			std::thread thr(processor::run, std::ref(proc), std::ref(prog)); где proc - экземпляр класса процессора, а prog - экземпляр класса progmem
			@param progmem ссылка на память программ
		*/
		void run(const progmem &progmem);
		/*!
			@brief Проверяет, является ли данный операнд заблокирован каким-либо АЛУ
			@param op ссылка на операнд
			@return true, если операнд свободен, false если его заблокировало какое-либо АЛУ
		*/
		bool is_free(const operand& op) const;
		/*!
			@brief возвращает слот памяти, на который ссылается операнд (содержит рекурсию, так как reg_operand и ram_operand могут хранить адреса в других операндах)
			@throws std::logic_error если была произведена попытка получить слот памяти для label_operand или const_operand
			@param op ссылка на операнд
			@return ссылку на слот памяти slot
		*/
		slot& get_slot(const operand& op);
		/*!
			@brief возвращает слот памяти, на который ссылается операнд, в режиме "только для чтения" (содержит рекурсию, так как reg_operand и ram_operand могут хранить адреса в других операндах)
			@throws std::logic_error если была произведена попытка получить слот памяти для label_operand или const_operand
			@param op ссылка на операнд
			@return константную ссылку на слот памяти slot
		*/
		const slot& get_slot(const operand& op) const;
		/*!
			@brief возвращает фактическое значение переданного операнда (содержит рекурсию, так как reg_operand и ram_operand могут хранить адреса в других операндах)
			@param op ссылка на операнд
			@return константную ссылку на слот памяти slot
		*/
		byte get_value(const operand& op) const;
		/// возвращает ссылку на описатель исполняемого процесса
		process& get_process() {return prog;}
		/// возвращает константную ссылку на описатель исполняемого процесса
		const process& get_process() const {return prog;}
		
		/// добавляет экземпляр АЛУ в набор АЛУ процессора
		void add_alu(const ALU& alu){alus.push_back(alu);}
		/// добавляет экземпляр АЛУ в набор АЛУ процессора, используя семантику перемещения АЛУ
		void add_alu(ALU&& alu){alus.push_back(alu);} 
		/// удаляет АЛУ из набора АЛУ процессора по номеру
		void remove_alu(int a){alus.erase(alus.begin()+a);}
		/// возвращает АЛУ по номеру для возможности редактирования
		ALU& edit_alu(int a){return alus[a];}
				
		/// возвращает итератор на начало вектора АЛУ
		auto al_begin(){return alus.begin();}
		/// возвращает итератор на конец вектора АЛУ
		auto al_end() const {return alus.end();}
		
		/// возвраащет общее количество регистров процессора
		int reg_count() const {return regs.get_size();}
		/// предостовляет доступ к указанному регистру из блока регистров процессора
		slot& reg_access(byte i) {return regs[i];} 
		/// предостовляет доступ к указанному регистру из блока регистров процессора только для чтения
		const slot& read_reg(byte i) const {return regs[i];} 
		/// утанавливает указатель на ОП
		void set_RAM(RAM *ram_){ram = ram_;}
		/// возвращает указатель на ОП, котоырый был установлен в данном экземпляре процессора.
		RAM* get_RAM() const {return ram;}
	};
}

#include "operators.hpp"
#include "operations.h"

#endif