#ifndef MATRIX_H
#define MATRIX_H

/// элемент списка. Хранит указатель на следующий элемент, данные и позицию в строке.
template < class T > struct item {
  item < T > * next;
  int pos;
  T data;
};

/// класс список объектов
template < class T > class list {
  private:
    /// указатель на начало списка
    item < T > * _start;
  /// длинна списка
  int _size;
  public:
  /// конструктор. производит инициализацию
  list(int sz){_size = sz;}
    /// деструктор. Очищает список.
    ~list();
  /// вставить элемент на i позицию
  void insert(int, T);
  /// получить элемент по позиции
  T operator[](const int);
};
/// класс прямоугольной разреженной матрицы
template < class T > class matrix {
  private:
    /// функция, в которую пользователь может вставить критерий отбора числа.
    bool( * _comparator)(T);
    /// функция, производящая сложение T. (это сделано потому что мы не можем гарантировать складываемость объектов класса T и по этому всю ответсвенность сваливаем на юзверя))
    T (* _add)(T,T);
  /// массив списков чисел
  list <T>* _arr;
  /// количество строк и столбцов
  int _m, _n;
  /// строка чисел b.
  T * _b;
  public:
  /// конструктор. производит выделение памяти под матрицу
  matrix(int, int);
  /// деструктор. очищает память
  ~matrix();
  /// устанавливает функцию сложения T+T.
  inline void set_calculator(T ( * calc)(T,T)){_add = calc;}
  /// выводит на экран матрицу
  void print();
  /// производит вычисление вектора b
  void calculate();
  /// выводит на экран искомый вектор b
  void print_b();
  /// оператор доступа к i строке. Позволителен синтаксис прямой работы с двумерной матрицей a[i][j]; но только для чтения
  list<T> & operator[](const int);
  /// возвращает количество строк в матрице.
  int rows() {
    return _m;
  }
  /// возвращает количество столбцов в матрице.
  int coulms() {
    return _n;
  }
  /// устанавливает функцию-предикат, отбирающая числа строки для сложения.
  inline void set_comparator(bool( * pred)(T)) {	_comparator = pred;}
};
#endif